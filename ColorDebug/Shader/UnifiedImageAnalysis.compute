// Unified Image Analysis Compute Shader
// Contains Histogram, Vectorscope, Waveform, and Saliency analysis

#pragma kernel KHistogramClear
#pragma kernel KHistogramGather
#pragma kernel KVectorscopeClear
#pragma kernel KVectorscopeGather
#pragma kernel KWaveformClear
#pragma kernel KWaveformGather
#pragma kernel KSaliencyMap
#pragma kernel KSaliencyReduce
#pragma kernel KColorPaletteExtract
#pragma kernel KColorPaletteClear

#define HISTOGRAM_BINS 256
#define GROUP_SIZE_X 16
#define GROUP_SIZE_Y 16

// === SHARED RESOURCES ===
Texture2D<float4> _Source;
SamplerState sampler_Source
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

float4 _Params; // Usage varies by kernel - see individual sections

// === SHARED UTILITY FUNCTIONS ===
// Linear to sRGB conversion
float3 LinearToSRGB(float3 color)
{
    float3 result;
    result.x = color.x <= 0.0031308 ? 12.92 * color.x : 1.055 * pow(color.x, 1.0 / 2.4) - 0.055;
    result.y = color.y <= 0.0031308 ? 12.92 * color.y : 1.055 * pow(color.y, 1.0 / 2.4) - 0.055;
    result.z = color.z <= 0.0031308 ? 12.92 * color.z : 1.055 * pow(color.z, 1.0 / 2.4) - 0.055;
    return result;
}

// RGB to YCbCr conversion (ITU-R BT.601)
float3 RgbToYCbCr(float3 rgb)
{
    float3 yuv;
    yuv.x = dot(rgb, float3(0.299, 0.587, 0.114)); // Y (luminance)
    yuv.y = (rgb.b - yuv.x) * 0.564 + 0.5; // Cb (blue-difference)
    yuv.z = (rgb.r - yuv.x) * 0.713 + 0.5; // Cr (red-difference)
    return yuv;
}

// ========================================
// HISTOGRAM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z/w = unused
RWStructuredBuffer<uint> _HistogramBuffer;

[numthreads(GROUP_SIZE_X, 1, 1)]
void KHistogramClear(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // RGB + Luminance = 4 channels
    if (dispatchThreadId.x < HISTOGRAM_BINS * 4)
        _HistogramBuffer[dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KHistogramGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = _Source[dispatchThreadId].rgb;
    
    // Calculate luminance using standard weights
    float luminance = dot(color, float3(0.299, 0.587, 0.114));
    
    uint idx_r = (uint) (saturate(color.r) * 255.0);
    uint idx_g = (uint) (saturate(color.g) * 255.0);
    uint idx_b = (uint) (saturate(color.b) * 255.0);
    uint idx_l = (uint) (saturate(luminance) * 255.0);

    InterlockedAdd(_HistogramBuffer[idx_r], 1u);
    InterlockedAdd(_HistogramBuffer[idx_g + HISTOGRAM_BINS], 1u);
    InterlockedAdd(_HistogramBuffer[idx_b + HISTOGRAM_BINS * 2], 1u);
    InterlockedAdd(_HistogramBuffer[idx_l + HISTOGRAM_BINS * 3], 1u);
}

// ========================================
// VECTORSCOPE ANALYSIS  
// ========================================
// _Params: x = source width, y = source height, z = buffer size, w = linear?
RWStructuredBuffer<uint> _VectorscopeBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    uint bufferSize = (uint) _Params.z;
    if (dispatchThreadId.x < bufferSize && dispatchThreadId.y < bufferSize)
        _VectorscopeBuffer[dispatchThreadId.y * bufferSize + dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[dispatchThreadId].rgb);

    // Apply gamma correction if needed
    if (_Params.w > 0)
        color = LinearToSRGB(color);

    // Convert to YCbCr color space
    float3 yuv = RgbToYCbCr(color);
    
    // Map Cb and Cr to buffer coordinates
    uint u = (uint) (saturate(yuv.y) * (_Params.z - 1.0));
    uint v = (uint) (saturate(yuv.z) * (_Params.z - 1.0));
    
    uint bufferSize = (uint) _Params.z;
    InterlockedAdd(_VectorscopeBuffer[v * bufferSize + u], 1u);
}

// ========================================
// WAVEFORM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z = linear?, w = unused
RWStructuredBuffer<uint4> _WaveformBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x < (uint) _Params.x && dispatchThreadId.y < (uint) _Params.y)
        _WaveformBuffer[dispatchThreadId.y * (uint) _Params.x + dispatchThreadId.x] = uint4(0u, 0u, 0u, 0u);
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformGather(uint2 id : SV_DispatchThreadID)
{
    // Params.x = srcWidth, Params.y = srcHeight
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[id].rgb); // sRGB 그대로 사용

    uint bins = (uint) _Params.y; // 세로축 해상도 = 히스토그램 bins
    uint3 idx = (uint3) (color * (bins - 1));

    uint base = id.x * bins; // x*height + y  (픽셀셰이더와 동일)
    InterlockedAdd(_WaveformBuffer[base + idx.x].x, 1u); // R
    InterlockedAdd(_WaveformBuffer[base + idx.y].y, 1u); // G
    InterlockedAdd(_WaveformBuffer[base + idx.z].z, 1u); // B
}

// ========================================
// SALIENCY MAP ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z/w = unused
RWTexture2D<float> _SaliencyMap;
struct MinMax
{
    float minVal;
    float maxVal;
};
RWStructuredBuffer<MinMax> _MinMaxBuffer;
groupshared MinMax minMaxShared[GROUP_SIZE_X * GROUP_SIZE_Y];


[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KSaliencyMap(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    // 현재 픽셀의 색상
    float3 color = saturate(_Source[id].rgb);
    
    // BMS (Boolean Map Saliency) 구현
    // 1. 밝기 임계값 체크
    float luminance = dot(color, float3(0.2126, 0.7152, 0.0722));
    bool brightPixel = luminance > 0.5;
    
    // 2. 채도 임계값 체크  
    float maxRGB = max(color.r, max(color.g, color.b));
    float minRGB = min(color.r, min(color.g, color.b));
    float saturation = (maxRGB > 0.001) ? (maxRGB - minRGB) / maxRGB : 0.0;
    bool saturatedPixel = saturation > 0.3;
    
    // 3. 지역적 명도 대비 체크 (3x3 윈도우)
    float avgLuminance = 0.0;
    int validSamples = 0;
    
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            int2 samplePos = int2(id) + int2(dx, dy);
            if (samplePos.x >= 0 && samplePos.x < (int) _Params.x &&
                samplePos.y >= 0 && samplePos.y < (int) _Params.y)
            {
                if (dx != 0 || dy != 0) // 중심 픽셀 제외
                {
                    float3 sampleColor = saturate(_Source[samplePos].rgb);
                    float sampleLum = dot(sampleColor, float3(0.2126, 0.7152, 0.0722));
                    avgLuminance += sampleLum;
                    validSamples++;
                }
            }
        }
    }
    
    if (validSamples > 0)
        avgLuminance /= validSamples;
    
    bool contrastPixel = abs(luminance - avgLuminance) > 0.15;
    
    // 4. 색상 고유성 체크 (주변과 색상 차이)
    float3 avgColor = float3(0, 0, 0);
    validSamples = 0;
    
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            int2 samplePos = int2(id) + int2(dx, dy);
            if (samplePos.x >= 0 && samplePos.x < (int) _Params.x &&
                samplePos.y >= 0 && samplePos.y < (int) _Params.y)
            {
                if (dx != 0 || dy != 0)
                {
                    float3 sampleColor = saturate(_Source[samplePos].rgb);
                    avgColor += sampleColor;
                    validSamples++;
                }
            }
        }
    }
    
    if (validSamples > 0)
        avgColor /= validSamples;
    
    float colorDistance = length(color - avgColor);
    bool uniqueColorPixel = colorDistance > 0.2;
    
    // BMS 최종 계산: Boolean 조건들의 가중합
    float saliency = 0.0;
    
    // 각 조건에 가중치 부여 (증폭)
    if (brightPixel) saliency += 0.25;
    if (saturatedPixel) saliency += 0.35;
    if (contrastPixel) saliency += 0.35;
    if (uniqueColorPixel) saliency += 0.25;
    
    // 복합 조건 보너스 (증폭)
    if (saturatedPixel && contrastPixel) saliency += 0.3; // 채도 + 명도대비
    if (brightPixel && uniqueColorPixel) saliency += 0.2;  // 밝기 + 색상고유성
    if (saturatedPixel && uniqueColorPixel) saliency += 0.2; // 채도 + 색상고유성
    
    // 추가 보너스 (레드 영역 확보)
    if (saturatedPixel && contrastPixel && uniqueColorPixel) saliency += 0.3;
    
    // 최종 정규화 (더 넓은 범위 활용)
    saliency = saliency / 1.9; // 최대 가능값으로 나누어 정규화
    saliency = saturate(saliency);
    
    // 극대화된 대비 강화 - 낮은 값은 거의 0으로, 높은 값은 최대로
    saliency = saliency * saliency * saliency * (3.0 - 2.0 * saliency); // 더 가파른 S커브
    
    // 최종 대비 강화 - 상위 영역을 더욱 강조
    saliency = pow(saliency, 0.3);

    _SaliencyMap[id] = saliency;
}

// ========================================
// COLOR PALETTE ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z = palette size, w = unused
RWStructuredBuffer<float4> _ColorPaletteBuffer;
RWStructuredBuffer<uint> _ColorCountBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KColorPaletteClear(uint3 id : SV_DispatchThreadID)
{
    uint paletteSize = (uint)_Params.z;
    if (id.x < paletteSize)
    {
        _ColorPaletteBuffer[id.x] = float4(0, 0, 0, 0);
        _ColorCountBuffer[id.x] = 0;
    }
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KColorPaletteExtract(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Params.x || id.y >= (uint)_Params.y)
        return;

    float3 color = saturate(_Source[id].rgb);
    uint paletteSize = (uint)_Params.z;
    
    // 색상을 16단계로 양자화하여 더 세밀한 색상 추출
    uint r = (uint)(color.r * 15.0);
    uint g = (uint)(color.g * 15.0);  
    uint b = (uint)(color.b * 15.0);
    
    // RGB를 하나의 인덱스로 변환 (4096가지 가능한 색상)
    uint colorHash = (r << 8) | (g << 4) | b; // 12bit 색상 해시
    uint paletteIndex = colorHash % paletteSize;
    
    // 해당 슬롯이 비어있거나, 같은 색상이면 업데이트
    uint oldCount;
    InterlockedAdd(_ColorCountBuffer[paletteIndex], 1u, oldCount);
    
    if (oldCount == 0)
    {
        // 첫 번째 색상이면 색상 저장
        _ColorPaletteBuffer[paletteIndex] = float4(color, 1.0);
    }
    else
    {
        // 기존 색상과 새 색상의 평균 계산 (점진적 평균)
        float4 existingColor = _ColorPaletteBuffer[paletteIndex];
        float weight = 1.0 / (oldCount + 1.0);
        _ColorPaletteBuffer[paletteIndex] = lerp(existingColor, float4(color, 1.0), weight);
    }
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KSaliencyReduce(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    uint2 dim;
    _SaliencyMap.GetDimensions(dim.x, dim.y);

    // 각 스레드가 saliency map에서 값을 하나씩 로드
    float val = 1.0; // out-of-bounds일 경우를 대비한 기본값
    if (id.x < dim.x && id.y < dim.y) {
        val = _SaliencyMap[id.xy];
    }

    minMaxShared[groupIndex].minVal = val;
    minMaxShared[groupIndex].maxVal = val;
    GroupMemoryBarrierWithGroupSync();

    // 그룹 내에서 병렬 감소 연산
    for (uint s = (GROUP_SIZE_X * GROUP_SIZE_Y) / 2; s > 0; s >>= 1)
    {
        if (groupIndex < s)
        {
            minMaxShared[groupIndex].minVal = min(minMaxShared[groupIndex].minVal, minMaxShared[groupIndex + s].minVal);
            minMaxShared[groupIndex].maxVal = max(minMaxShared[groupIndex].maxVal, minMaxShared[groupIndex + s].maxVal);
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // 그룹의 첫 번째 스레드가 그룹의 결과를 버퍼에 기록
    if (groupIndex == 0)
    {
        uint numGroupsX = (dim.x + GROUP_SIZE_X - 1) / GROUP_SIZE_X;
        uint bufferIndex = groupID.y * numGroupsX + groupID.x;
        _MinMaxBuffer[bufferIndex] = minMaxShared[0];
    }
}
