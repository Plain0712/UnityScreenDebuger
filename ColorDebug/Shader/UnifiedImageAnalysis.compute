// Unified Image Analysis Compute Shader
// Contains Histogram, Vectorscope, and Waveform analysis

#pragma kernel KHistogramClear
#pragma kernel KHistogramGather
#pragma kernel KVectorscopeClear
#pragma kernel KVectorscopeGather
#pragma kernel KWaveformClear
#pragma kernel KWaveformGather
#pragma kernel KSaliencyMap


#define HISTOGRAM_BINS 256
#define GROUP_SIZE_X 16
#define GROUP_SIZE_Y 16

// === SHARED RESOURCES ===
Texture2D<float4> _Source;
SamplerState sampler_Source
{
    Filter = MIN_MAG_MIP_POINT; // 또는 LINEAR
    AddressU = Clamp;
    AddressV = Clamp;
};

float4 _Params; // Usage varies by kernel - see individual sections

// === SHARED UTILITY FUNCTIONS ===
// Linear to sRGB conversion
float3 LinearToSRGB(float3 color)
{
    float3 result;
    result.x = color.x <= 0.0031308 ? 12.92 * color.x : 1.055 * pow(color.x, 1.0 / 2.4) - 0.055;
    result.y = color.y <= 0.0031308 ? 12.92 * color.y : 1.055 * pow(color.y, 1.0 / 2.4) - 0.055;
    result.z = color.z <= 0.0031308 ? 12.92 * color.z : 1.055 * pow(color.z, 1.0 / 2.4) - 0.055;
    return result;
}

// RGB to YCbCr conversion (ITU-R BT.601)
float3 RgbToYCbCr(float3 rgb)
{
    float3 yuv;
    yuv.x = dot(rgb, float3(0.299, 0.587, 0.114)); // Y (luminance)
    yuv.y = (rgb.b - yuv.x) * 0.564 + 0.5; // Cb (blue-difference)
    yuv.z = (rgb.r - yuv.x) * 0.713 + 0.5; // Cr (red-difference)
    return yuv;
}



// ========================================
// HISTOGRAM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z/w = unused
RWStructuredBuffer<uint> _HistogramBuffer;

[numthreads(GROUP_SIZE_X, 1, 1)]
void KHistogramClear(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // RGB + Luminance = 4 channels
    if (dispatchThreadId.x < HISTOGRAM_BINS * 4)
        _HistogramBuffer[dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KHistogramGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = _Source[dispatchThreadId].rgb;
    
    // Calculate luminance using standard weights
    float luminance = dot(color, float3(0.299, 0.587, 0.114));
    
    uint idx_r = (uint) (saturate(color.r) * 255.0);
    uint idx_g = (uint) (saturate(color.g) * 255.0);
    uint idx_b = (uint) (saturate(color.b) * 255.0);
    uint idx_l = (uint) (saturate(luminance) * 255.0);

    InterlockedAdd(_HistogramBuffer[idx_r], 1u);
    InterlockedAdd(_HistogramBuffer[idx_g + HISTOGRAM_BINS], 1u);
    InterlockedAdd(_HistogramBuffer[idx_b + HISTOGRAM_BINS * 2], 1u);
    InterlockedAdd(_HistogramBuffer[idx_l + HISTOGRAM_BINS * 3], 1u);
}

// ========================================
// VECTORSCOPE ANALYSIS  
// ========================================
// _Params: x = source width, y = source height, z = buffer size, w = linear?
RWStructuredBuffer<uint> _VectorscopeBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    uint bufferSize = (uint) _Params.z;
    if (dispatchThreadId.x < bufferSize && dispatchThreadId.y < bufferSize)
        _VectorscopeBuffer[dispatchThreadId.y * bufferSize + dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[dispatchThreadId].rgb);

    // Apply gamma correction if needed
    if (_Params.w > 0)
        color = LinearToSRGB(color);

    // Convert to YCbCr color space
    float3 yuv = RgbToYCbCr(color);
    
    // Map Cb and Cr to buffer coordinates
    uint u = (uint) (saturate(yuv.y) * (_Params.z - 1.0));
    uint v = (uint) (saturate(yuv.z) * (_Params.z - 1.0));
    
    uint bufferSize = (uint) _Params.z;
    InterlockedAdd(_VectorscopeBuffer[v * bufferSize + u], 1u);
}

// ========================================
// WAVEFORM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z = linear?, w = unused
RWStructuredBuffer<uint4> _WaveformBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x < (uint) _Params.x && dispatchThreadId.y < (uint) _Params.y)
        _WaveformBuffer[dispatchThreadId.y * (uint) _Params.x + dispatchThreadId.x] = uint4(0u, 0u, 0u, 0u);
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformGather(uint2 id : SV_DispatchThreadID)
{
    // Params.x = srcWidth, Params.y = srcHeight
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[id].rgb); // sRGB 그대로 사용

    uint bins = (uint) _Params.y; // 세로축 해상도 = 히스토그램 bins
    uint3 idx = (uint3) (color * (bins - 1));

    uint base = id.x * bins; // x*height + y  (픽셀셰이더와 동일)
    InterlockedAdd(_WaveformBuffer[base + idx.x].x, 1u); // R
    InterlockedAdd(_WaveformBuffer[base + idx.y].y, 1u); // G
    InterlockedAdd(_WaveformBuffer[base + idx.z].z, 1u); // B
}

// ──────────────────────────────────────────────
// Saliency Map Kernel
// output: RWTexture2D<float> _SaliencyMap
// _Params.xy = (srcW, srcH)
// _Params.z  = unused
// ──────────────────────────────────────────────

RWTexture2D<float> _SaliencyMap;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KSaliencyMap(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    float2 uv = (id + 0.5) / _Params.xy;

    float3 color = _Source.SampleLevel(sampler_Source, uv, 0).rgb;

    // ─── 1. Luminance
    float luminance = dot(color, float3(0.2126, 0.7152, 0.0722));
    float lumContrast = abs(luminance - 0.5) * 2.0; // 중심에서 멀수록 강함

    // ─── 2. Saturation
    float maxRGB = max(color.r, max(color.g, color.b));
    float minRGB = min(color.r, min(color.g, color.b));
    float saturation = (maxRGB == 0) ? 0 : (maxRGB - minRGB) / maxRGB;

    // ─── 3. Edge (gradient magnitude on luminance)
    float lum_dx = 0, lum_dy = 0;
    if (id.x < (uint) _Params.x - 1)
    {
        float3 colR = saturate(_Source[id + uint2(1, 0)].rgb);
        float lumR = dot(colR, float3(0.2126, 0.7152, 0.0722));
        lum_dx = lumR - luminance;
    }
    if (id.y < (uint) _Params.y - 1)
    {
        float3 colD = saturate(_Source[id + uint2(0, 1)].rgb);
        float lumD = dot(colD, float3(0.2126, 0.7152, 0.0722));
        lum_dy = lumD - luminance;
    }

    float edge = sqrt(lum_dx * lum_dx + lum_dy * lum_dy); // simple gradient

    // ─── 최종 가중합
    float saliency = lumContrast * 0.4 + saturation * 0.4 + edge * 0.2;

    _SaliencyMap[id] = saliency;
}


