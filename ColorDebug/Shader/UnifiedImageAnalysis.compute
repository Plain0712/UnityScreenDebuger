// Unified Image Analysis Compute Shader
// Contains Histogram, Vectorscope, Waveform, and Saliency analysis

#pragma kernel KHistogramClear
#pragma kernel KHistogramGather
#pragma kernel KVectorscopeClear
#pragma kernel KVectorscopeGather
#pragma kernel KWaveformClear
#pragma kernel KWaveformGather
#pragma kernel KSaliencyMap
#pragma kernel KSaliencyReduce
#pragma kernel KColorPaletteClear
#pragma kernel KColorPaletteExtract

#define HISTOGRAM_BINS 256
#define GROUP_SIZE_X 16
#define GROUP_SIZE_Y 16

// === SHARED RESOURCES ===
Texture2D<float4> _Source;
SamplerState sampler_Source
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

float4 _Params; // Usage varies by kernel - see individual sections

// === SHARED UTILITY FUNCTIONS ===
// Linear to sRGB conversion
float3 LinearToSRGB(float3 color)
{
    float3 result;
    result.x = color.x <= 0.0031308 ? 12.92 * color.x : 1.055 * pow(color.x, 1.0 / 2.4) - 0.055;
    result.y = color.y <= 0.0031308 ? 12.92 * color.y : 1.055 * pow(color.y, 1.0 / 2.4) - 0.055;
    result.z = color.z <= 0.0031308 ? 12.92 * color.z : 1.055 * pow(color.z, 1.0 / 2.4) - 0.055;
    return result;
}

// RGB to YCbCr conversion (ITU-R BT.601)
float3 RgbToYCbCr(float3 rgb)
{
    float3 yuv;
    yuv.x = dot(rgb, float3(0.299, 0.587, 0.114)); // Y (luminance)
    yuv.y = (rgb.b - yuv.x) * 0.564 + 0.5; // Cb (blue-difference)
    yuv.z = (rgb.r - yuv.x) * 0.713 + 0.5; // Cr (red-difference)
    return yuv;
}

// ========================================
// HISTOGRAM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z/w = unused
RWStructuredBuffer<uint> _HistogramBuffer;

[numthreads(GROUP_SIZE_X, 1, 1)]
void KHistogramClear(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // RGB + Luminance = 4 channels
    if (dispatchThreadId.x < HISTOGRAM_BINS * 4)
        _HistogramBuffer[dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KHistogramGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = _Source[dispatchThreadId].rgb;
    
    // Calculate luminance using standard weights
    float luminance = dot(color, float3(0.299, 0.587, 0.114));
    
    uint idx_r = (uint) (saturate(color.r) * 255.0);
    uint idx_g = (uint) (saturate(color.g) * 255.0);
    uint idx_b = (uint) (saturate(color.b) * 255.0);
    uint idx_l = (uint) (saturate(luminance) * 255.0);

    InterlockedAdd(_HistogramBuffer[idx_r], 1u);
    InterlockedAdd(_HistogramBuffer[idx_g + HISTOGRAM_BINS], 1u);
    InterlockedAdd(_HistogramBuffer[idx_b + HISTOGRAM_BINS * 2], 1u);
    InterlockedAdd(_HistogramBuffer[idx_l + HISTOGRAM_BINS * 3], 1u);
}

// ========================================
// VECTORSCOPE ANALYSIS  
// ========================================
// _Params: x = source width, y = source height, z = buffer size, w = linear?
RWStructuredBuffer<uint> _VectorscopeBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    uint bufferSize = (uint) _Params.z;
    if (dispatchThreadId.x < bufferSize && dispatchThreadId.y < bufferSize)
        _VectorscopeBuffer[dispatchThreadId.y * bufferSize + dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[dispatchThreadId].rgb);

    // Apply gamma correction if needed
    if (_Params.w > 0)
        color = LinearToSRGB(color);

    // Convert to YCbCr color space
    float3 yuv = RgbToYCbCr(color);
    
    // Map Cb and Cr to buffer coordinates
    uint u = (uint) (saturate(yuv.y) * (_Params.z - 1.0));
    uint v = (uint) (saturate(yuv.z) * (_Params.z - 1.0));
    
    uint bufferSize = (uint) _Params.z;
    InterlockedAdd(_VectorscopeBuffer[v * bufferSize + u], 1u);
}

// ========================================
// WAVEFORM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z = linear?, w = unused
RWStructuredBuffer<uint4> _WaveformBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x < (uint) _Params.x && dispatchThreadId.y < (uint) _Params.y)
        _WaveformBuffer[dispatchThreadId.y * (uint) _Params.x + dispatchThreadId.x] = uint4(0u, 0u, 0u, 0u);
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformGather(uint2 id : SV_DispatchThreadID)
{
    // Params.x = srcWidth, Params.y = srcHeight
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[id].rgb); // sRGB 그대로 사용

    uint bins = (uint) _Params.y; // 세로축 해상도 = 히스토그램 bins
    uint3 idx = (uint3) (color * (bins - 1));

    uint base = id.x * bins; // x*height + y  (픽셀셰이더와 동일)
    InterlockedAdd(_WaveformBuffer[base + idx.x].x, 1u); // R
    InterlockedAdd(_WaveformBuffer[base + idx.y].y, 1u); // G
    InterlockedAdd(_WaveformBuffer[base + idx.z].z, 1u); // B
}

// ========================================
// SALIENCY MAP ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z/w = unused
RWTexture2D<float> _SaliencyMap;
struct MinMax
{
    float minVal;
    float maxVal;
};
RWStructuredBuffer<MinMax> _MinMaxBuffer;
groupshared MinMax minMaxShared[GROUP_SIZE_X * GROUP_SIZE_Y];


[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KSaliencyMap(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    // 현재 픽셀의 색상
    float3 color = saturate(_Source[id].rgb);
    
    // BMS (Boolean Map Saliency) 구현
    // 1. 밝기 임계값 체크
    float luminance = dot(color, float3(0.2126, 0.7152, 0.0722));
    bool brightPixel = luminance > 0.5;
    
    // 2. 채도 임계값 체크  
    float maxRGB = max(color.r, max(color.g, color.b));
    float minRGB = min(color.r, min(color.g, color.b));
    float saturation = (maxRGB > 0.001) ? (maxRGB - minRGB) / maxRGB : 0.0;
    bool saturatedPixel = saturation > 0.3;
    
    // 3. 지역적 명도 대비 체크 (3x3 윈도우)
    float avgLuminance = 0.0;
    int validSamples = 0;
    
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            int2 samplePos = int2(id) + int2(dx, dy);
            if (samplePos.x >= 0 && samplePos.x < (int) _Params.x &&
                samplePos.y >= 0 && samplePos.y < (int) _Params.y)
            {
                if (dx != 0 || dy != 0) // 중심 픽셀 제외
                {
                    float3 sampleColor = saturate(_Source[samplePos].rgb);
                    float sampleLum = dot(sampleColor, float3(0.2126, 0.7152, 0.0722));
                    avgLuminance += sampleLum;
                    validSamples++;
                }
            }
        }
    }
    
    if (validSamples > 0)
        avgLuminance /= validSamples;
    
    bool contrastPixel = abs(luminance - avgLuminance) > 0.15;
    
    // 4. 색상 고유성 체크 (주변과 색상 차이)
    float3 avgColor = float3(0, 0, 0);
    validSamples = 0;
    
    for (int dy2 = -1; dy2 <= 1; dy2++)
    {
        for (int dx2 = -1; dx2 <= 1; dx2++)
        {
            int2 samplePos = int2(id) + int2(dx2, dy2);
            if (samplePos.x >= 0 && samplePos.x < (int) _Params.x &&
                samplePos.y >= 0 && samplePos.y < (int) _Params.y)
            {
                if (dx2 != 0 || dy2 != 0)
                {
                    float3 sampleColor = saturate(_Source[samplePos].rgb);
                    avgColor += sampleColor;
                    validSamples++;
                }
            }
        }
    }
    
    if (validSamples > 0)
        avgColor /= validSamples;
    
    float colorDistance = length(color - avgColor);
    bool uniqueColorPixel = colorDistance > 0.2;
    
    // BMS 최종 계산: Boolean 조건들의 가중합
    float saliency = 0.0;
    
    // 각 조건에 가중치 부여 (증폭)
    if (brightPixel) saliency += 0.25;
    if (saturatedPixel) saliency += 0.35;
    if (contrastPixel) saliency += 0.35;
    if (uniqueColorPixel) saliency += 0.25;
    
    // 복합 조건 보너스 (증폭)
    if (saturatedPixel && contrastPixel) saliency += 0.3; // 채도 + 명도대비
    if (brightPixel && uniqueColorPixel) saliency += 0.2;  // 밝기 + 색상고유성
    if (saturatedPixel && uniqueColorPixel) saliency += 0.2; // 채도 + 색상고유성
    
    // 추가 보너스 (레드 영역 확보)
    if (saturatedPixel && contrastPixel && uniqueColorPixel) saliency += 0.3;
    
    // 최종 정규화 (더 넓은 범위 활용)
    saliency = saliency / 1.9; // 최대 가능값으로 나누어 정규화
    saliency = saturate(saliency);
    
    // 극대화된 대비 강화 - 낮은 값은 거의 0으로, 높은 값은 최대로
    saliency = saliency * saliency * saliency * (3.0 - 2.0 * saliency); // 더 가파른 S커브
    
    // 최종 대비 강화 - 상위 영역을 더욱 강조
    saliency = pow(saliency, 0.3);

    _SaliencyMap[id] = saliency;
}

// ========================================
// COLOR PALETTE ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z = palette size, w = unused
RWStructuredBuffer<float4> _ColorPaletteBuffer;
RWStructuredBuffer<uint> _ColorCountBuffer;

[numthreads(GROUP_SIZE_X, 1, 1)]
void KColorPaletteClear(uint3 id : SV_DispatchThreadID)
{
    uint paletteSize = (uint)_Params.z;
    if (id.x < paletteSize)
    {
        _ColorPaletteBuffer[id.x] = float4(0, 0, 0, 0);
        _ColorCountBuffer[id.x] = 0;
    }
}

// 지능형 3D 히스토그램 기반 색상 팔레트 추출
[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KColorPaletteExtract(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_Params.x || id.y >= (uint)_Params.y)
        return;

    float3 color = saturate(_Source[id].rgb);
    uint paletteSize = (uint)_Params.z;
    
    // === 1단계: 색상 중요도 계산 ===
    float luminance = dot(color, float3(0.299, 0.587, 0.114));
    float saturation = max(max(color.r, color.g), color.b) - min(min(color.r, color.g), color.b);
    
    // 시각적 중요도 스코어
    float importanceScore = 1.0;
    
    // 채도 보너스 (채도 높은 색상일수록 중요)
    importanceScore += saturation * 4.0;
    
    // 적당한 밝기 보너스 (너무 어둡거나 밝지 않은 색상)
    float brightnessBonus = 1.0 - abs(luminance - 0.5) * 2.0;
    importanceScore += brightnessBonus * 2.0;
    
    // 에지 검출 (주변 픽셀과의 차이)
    float edgeStrength = 0.0;
    if (id.x > 0 && id.y > 0 && id.x < (uint)_Params.x - 1 && id.y < (uint)_Params.y - 1)
    {
        float3 neighbors[4];
        neighbors[0] = _Source[id + uint2(1, 0)].rgb;  // 우
        neighbors[1] = _Source[id + uint2(-1, 0)].rgb; // 좌
        neighbors[2] = _Source[id + uint2(0, 1)].rgb;  // 아래
        neighbors[3] = _Source[id + uint2(0, -1)].rgb; // 위
        
        for (int i = 0; i < 4; i++)
        {
            float3 diff = color - neighbors[i];
            edgeStrength += dot(diff, diff);
        }
        edgeStrength /= 4.0;
    }
    
    // 에지 보너스 (윤곽선 근처의 색상은 더 중요)
    importanceScore += sqrt(edgeStrength) * 3.0;
    
    // === 2단계: 3D 히스토그램 빈 결정 ===
    // RGB 공간을 6x6x6으로 분할 (216개 빈)
    uint3 histBin = (uint3)(color * 5.99); // 0~5 범위
    uint binIndex = histBin.r * 36 + histBin.g * 6 + histBin.b;
    
    // 팔레트 슬롯에 매핑
    uint slotIndex = binIndex % paletteSize;
    
    // === 3단계: 가중 투표 및 색상 누적 ===
    uint weight = max(1, (uint)(importanceScore * 100.0));
    
    // 투표 수 증가
    InterlockedAdd(_ColorCountBuffer[slotIndex], weight);
    
    // 색상 누적 (가중 평균)
    // 기존 접근법의 문제: InterlockedAdd 후 바로 읽으면 race condition
    // 해결: 단순하게 덮어쓰기로 변경 (마지막 색상이 대표)
    _ColorPaletteBuffer[slotIndex] = float4(color, importanceScore);
}


[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KSaliencyReduce(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    uint2 dim;
    _SaliencyMap.GetDimensions(dim.x, dim.y);

    // 각 스레드가 saliency map에서 값을 하나씩 로드
    float val = 1.0; // out-of-bounds일 경우를 대비한 기본값
    if (id.x < dim.x && id.y < dim.y) {
        val = _SaliencyMap[id.xy];
    }

    minMaxShared[groupIndex].minVal = val;
    minMaxShared[groupIndex].maxVal = val;
    GroupMemoryBarrierWithGroupSync();

    // 그룹 내에서 병렬 감소 연산
    for (uint s = (GROUP_SIZE_X * GROUP_SIZE_Y) / 2; s > 0; s >>= 1)
    {
        if (groupIndex < s)
        {
            minMaxShared[groupIndex].minVal = min(minMaxShared[groupIndex].minVal, minMaxShared[groupIndex + s].minVal);
            minMaxShared[groupIndex].maxVal = max(minMaxShared[groupIndex].maxVal, minMaxShared[groupIndex + s].maxVal);
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // 그룹의 첫 번째 스레드가 그룹의 결과를 버퍼에 기록
    if (groupIndex == 0)
    {
        uint numGroupsX = (dim.x + GROUP_SIZE_X - 1) / GROUP_SIZE_X;
        uint bufferIndex = groupID.y * numGroupsX + groupID.x;
        _MinMaxBuffer[bufferIndex] = minMaxShared[0];
    }
}
