// Unified Image Analysis Compute Shader
// Contains Histogram, Vectorscope, Waveform, and Saliency analysis

#pragma kernel KHistogramClear
#pragma kernel KHistogramGather
#pragma kernel KVectorscopeClear
#pragma kernel KVectorscopeGather
#pragma kernel KWaveformClear
#pragma kernel KWaveformGather
#pragma kernel KSaliencyMap
#pragma kernel KSaliencyReduce

#define HISTOGRAM_BINS 256
#define GROUP_SIZE_X 16
#define GROUP_SIZE_Y 16

// === SHARED RESOURCES ===
Texture2D<float4> _Source;
SamplerState sampler_Source
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

float4 _Params; // Usage varies by kernel - see individual sections

// === SHARED UTILITY FUNCTIONS ===
// Linear to sRGB conversion
float3 LinearToSRGB(float3 color)
{
    float3 result;
    result.x = color.x <= 0.0031308 ? 12.92 * color.x : 1.055 * pow(color.x, 1.0 / 2.4) - 0.055;
    result.y = color.y <= 0.0031308 ? 12.92 * color.y : 1.055 * pow(color.y, 1.0 / 2.4) - 0.055;
    result.z = color.z <= 0.0031308 ? 12.92 * color.z : 1.055 * pow(color.z, 1.0 / 2.4) - 0.055;
    return result;
}

// RGB to YCbCr conversion (ITU-R BT.601)
float3 RgbToYCbCr(float3 rgb)
{
    float3 yuv;
    yuv.x = dot(rgb, float3(0.299, 0.587, 0.114)); // Y (luminance)
    yuv.y = (rgb.b - yuv.x) * 0.564 + 0.5; // Cb (blue-difference)
    yuv.z = (rgb.r - yuv.x) * 0.713 + 0.5; // Cr (red-difference)
    return yuv;
}

// ========================================
// HISTOGRAM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z/w = unused
RWStructuredBuffer<uint> _HistogramBuffer;

[numthreads(GROUP_SIZE_X, 1, 1)]
void KHistogramClear(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    // RGB + Luminance = 4 channels
    if (dispatchThreadId.x < HISTOGRAM_BINS * 4)
        _HistogramBuffer[dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KHistogramGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = _Source[dispatchThreadId].rgb;
    
    // Calculate luminance using standard weights
    float luminance = dot(color, float3(0.299, 0.587, 0.114));
    
    uint idx_r = (uint) (saturate(color.r) * 255.0);
    uint idx_g = (uint) (saturate(color.g) * 255.0);
    uint idx_b = (uint) (saturate(color.b) * 255.0);
    uint idx_l = (uint) (saturate(luminance) * 255.0);

    InterlockedAdd(_HistogramBuffer[idx_r], 1u);
    InterlockedAdd(_HistogramBuffer[idx_g + HISTOGRAM_BINS], 1u);
    InterlockedAdd(_HistogramBuffer[idx_b + HISTOGRAM_BINS * 2], 1u);
    InterlockedAdd(_HistogramBuffer[idx_l + HISTOGRAM_BINS * 3], 1u);
}

// ========================================
// VECTORSCOPE ANALYSIS  
// ========================================
// _Params: x = source width, y = source height, z = buffer size, w = linear?
RWStructuredBuffer<uint> _VectorscopeBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    uint bufferSize = (uint) _Params.z;
    if (dispatchThreadId.x < bufferSize && dispatchThreadId.y < bufferSize)
        _VectorscopeBuffer[dispatchThreadId.y * bufferSize + dispatchThreadId.x] = 0u;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KVectorscopeGather(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x >= (uint) _Params.x || dispatchThreadId.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[dispatchThreadId].rgb);

    // Apply gamma correction if needed
    if (_Params.w > 0)
        color = LinearToSRGB(color);

    // Convert to YCbCr color space
    float3 yuv = RgbToYCbCr(color);
    
    // Map Cb and Cr to buffer coordinates
    uint u = (uint) (saturate(yuv.y) * (_Params.z - 1.0));
    uint v = (uint) (saturate(yuv.z) * (_Params.z - 1.0));
    
    uint bufferSize = (uint) _Params.z;
    InterlockedAdd(_VectorscopeBuffer[v * bufferSize + u], 1u);
}

// ========================================
// WAVEFORM ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z = linear?, w = unused
RWStructuredBuffer<uint4> _WaveformBuffer;

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformClear(uint2 dispatchThreadId : SV_DispatchThreadID)
{
    if (dispatchThreadId.x < (uint) _Params.x && dispatchThreadId.y < (uint) _Params.y)
        _WaveformBuffer[dispatchThreadId.y * (uint) _Params.x + dispatchThreadId.x] = uint4(0u, 0u, 0u, 0u);
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KWaveformGather(uint2 id : SV_DispatchThreadID)
{
    // Params.x = srcWidth, Params.y = srcHeight
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    float3 color = saturate(_Source[id].rgb); // sRGB 그대로 사용

    uint bins = (uint) _Params.y; // 세로축 해상도 = 히스토그램 bins
    uint3 idx = (uint3) (color * (bins - 1));

    uint base = id.x * bins; // x*height + y  (픽셀셰이더와 동일)
    InterlockedAdd(_WaveformBuffer[base + idx.x].x, 1u); // R
    InterlockedAdd(_WaveformBuffer[base + idx.y].y, 1u); // G
    InterlockedAdd(_WaveformBuffer[base + idx.z].z, 1u); // B
}

// ========================================
// SALIENCY MAP ANALYSIS
// ========================================
// _Params: x = source width, y = source height, z/w = unused
RWTexture2D<float> _SaliencyMap;
struct MinMax
{
    float minVal;
    float maxVal;
};
RWStructuredBuffer<MinMax> _MinMaxBuffer;
groupshared MinMax minMaxShared[GROUP_SIZE_X * GROUP_SIZE_Y];


[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KSaliencyMap(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) _Params.x || id.y >= (uint) _Params.y)
        return;

    // 현재 픽셀의 색상
    float3 color = saturate(_Source[id].rgb);
    float luminance = dot(color, float3(0.2126, 0.7152, 0.0722));

    // ─── 1. Luminance Contrast (개선된 버전)
    float avgLuminance = 0.0;
    int sampleCount = 0;
    
    // 3x3 커널로 주변 픽셀 샘플링
    for (int dy = -1; dy <= 1; dy++)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            int2 samplePos = int2(id) + int2(dx, dy);
            if (samplePos.x >= 0 && samplePos.x < (int) _Params.x &&
                samplePos.y >= 0 && samplePos.y < (int) _Params.y)
            {
                if (dx != 0 || dy != 0) // 자기 자신 제외
                {
                    float3 sampleColor = saturate(_Source[samplePos].rgb);
                    float sampleLum = dot(sampleColor, float3(0.2126, 0.7152, 0.0722));
                    avgLuminance += sampleLum;
                    sampleCount++;
                }
            }
        }
    }
    
    if (sampleCount > 0)
        avgLuminance /= sampleCount;
    
    float lumContrast = abs(luminance - avgLuminance);

    // ─── 2. Saturation (개선된 계산)
    float maxRGB = max(color.r, max(color.g, color.b));
    float minRGB = min(color.r, min(color.g, color.b));
    float saturation = (maxRGB > 0.001) ? (maxRGB - minRGB) / maxRGB : 0.0;

    // ─── 3. Edge Detection (Sobel 연산자)
    float sobelX = 0.0;
    float sobelY = 0.0;
    
    // Sobel 커널
    int2 offsets[9] =
    {
        int2(-1, -1), int2(0, -1), int2(1, -1),
        int2(-1, 0), int2(0, 0), int2(1, 0),
        int2(-1, 1), int2(0, 1), int2(1, 1)
    };
    
    float sobelXKernel[9] = { -1, 0, 1, -2, 0, 2, -1, 0, 1 };
    float sobelYKernel[9] = { -1, -2, -1, 0, 0, 0, 1, 2, 1 };
    
    for (int i = 0; i < 9; i++)
    {
        int2 samplePos = int2(id) + offsets[i];
        if (samplePos.x >= 0 && samplePos.x < (int) _Params.x &&
            samplePos.y >= 0 && samplePos.y < (int) _Params.y)
        {
            float3 sampleColor = saturate(_Source[samplePos].rgb);
            float sampleLum = dot(sampleColor, float3(0.2126, 0.7152, 0.0722));
            
            sobelX += sampleLum * sobelXKernel[i];
            sobelY += sampleLum * sobelYKernel[i];
        }
    }
    
    float edge = sqrt(sobelX * sobelX + sobelY * sobelY);

    // ─── 4. Color Uniqueness
    float colorUniqueness = 0.0;
    float3 avgColor = float3(0, 0, 0);
    sampleCount = 0;
    
    // 5x5 영역에서 색상 유사도 계산
    for (int dy = -2; dy <= 2; dy++)
    {
        for (int dx = -2; dx <= 2; dx++)
        {
            int2 samplePos = int2(id) + int2(dx, dy);
            if (samplePos.x >= 0 && samplePos.x < (int) _Params.x &&
                samplePos.y >= 0 && samplePos.y < (int) _Params.y)
            {
                if (dx != 0 || dy != 0)
                {
                    float3 sampleColor = saturate(_Source[samplePos].rgb);
                    avgColor += sampleColor;
                    sampleCount++;
                }
            }
        }
    }
    
    if (sampleCount > 0)
    {
        avgColor /= sampleCount;
        colorUniqueness = length(color - avgColor);
    }

    // ─── 최종 가중합 및 정규화
    float saliency = lumContrast * 2.0 + saturation * 1.5 + edge * 1.0 + colorUniqueness * 1.2;
    
    // 0-1 범위로 정규화
    saliency = saturate(saliency);
    
    // 대비 강화를 위한 감마 보정
    saliency = pow(saliency, 0.8);

    _SaliencyMap[id] = saliency;
}

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void KSaliencyReduce(uint3 id : SV_DispatchThreadID, uint groupIndex : SV_GroupIndex, uint3 groupID : SV_GroupID)
{
    uint2 dim;
    _SaliencyMap.GetDimensions(dim.x, dim.y);

    // 각 스레드가 saliency map에서 값을 하나씩 로드
    float val = 1.0; // out-of-bounds일 경우를 대비한 기본값
    if (id.x < dim.x && id.y < dim.y) {
        val = _SaliencyMap[id.xy];
    }

    minMaxShared[groupIndex].minVal = val;
    minMaxShared[groupIndex].maxVal = val;
    GroupMemoryBarrierWithGroupSync();

    // 그룹 내에서 병렬 감소 연산
    for (uint s = (GROUP_SIZE_X * GROUP_SIZE_Y) / 2; s > 0; s >>= 1)
    {
        if (groupIndex < s)
        {
            minMaxShared[groupIndex].minVal = min(minMaxShared[groupIndex].minVal, minMaxShared[groupIndex + s].minVal);
            minMaxShared[groupIndex].maxVal = max(minMaxShared[groupIndex].maxVal, minMaxShared[groupIndex + s].maxVal);
        }
        GroupMemoryBarrierWithGroupSync();
    }

    // 그룹의 첫 번째 스레드가 그룹의 결과를 버퍼에 기록
    if (groupIndex == 0)
    {
        uint numGroupsX = (dim.x + GROUP_SIZE_X - 1) / GROUP_SIZE_X;
        uint bufferIndex = groupID.y * numGroupsX + groupID.x;
        _MinMaxBuffer[bufferIndex] = minMaxShared[0];
    }
}
